{"version":3,"file":"router-sdk.cjs.production.min.js","sources":["../src/approveAndCall.ts","../src/constants.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../src/entities/protocol.ts","../node_modules/regenerator-runtime/runtime.js","../src/entities/route.ts","../src/entities/trade.ts","../src/swapRouter.ts"],"sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw 'Error: invalid ApprovalType'\n    }\n  }\n}\n","import JSBI from 'jsbi'\n\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool } from '@uniswap/v3-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pool | Pair> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Token[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../constants'\nimport { Protocol } from './protocol'\nimport { IRoute, RouteV2, RouteV3 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    tradeType,\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (route.protocol == Protocol.V3) {\n          poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, (pool as Pool).fee))\n        } else {\n          const pair = pool\n          poolAddressSet.add(Pair.getAddress(pair.token0, pair.token1))\n        }\n      }\n    }\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      tradeType,\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n      v3Routes = []\n    } else {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n      v2Routes = []\n    }\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      tradeType,\n    })\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\n\nconst ZERO = JSBI.BigInt(0)\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade: V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual V2Trade and V3Trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every((swap) => swap.route.protocol == Protocol.V3 || swap.route.protocol == Protocol.V2),\n        'UNSUPPORTED_PROTOCOL'\n      )\n\n      let v2Andv3Trades: (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol == Protocol.V2) {\n          v2Andv3Trades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol == Protocol.V3) {\n          v2Andv3Trades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        }\n      }\n      trades = v2Andv3Trades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) => numberOfTrades + (trade instanceof V3Trade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH, but with an uncertain input amount\n    if (inputIsNative && sampleTrade.tradeType === TradeType.EXACT_OUTPUT) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): { positionAmountIn: CurrencyAmount<Currency>; positionAmountOut: CurrencyAmount<Currency> } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"],"names":["ApprovalTypes","MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","BigInt","ONE","isMint","options","Object","keys","some","k","ApproveAndCall","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","length","invariant","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","mintAmountsWithSlippage","amount0Min","amount0","amount1Min","amount1","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","Interface","abi","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","bytes32","match","Error","toLowerCase","validateAndParseBytes32","deadline","encodeFeeBips","multiply","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","Protocol","runtime","exports","Op","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","RouteV2","v2Route","pairs","input","output","V2","pools","_this","V2RouteSDK","RouteV3","v3Route","V3","path","tokenPath","V3RouteSDK","Trade","v2Routes","v3Routes","tradeType","swaps","routes","inputAmount","outputAmount","route","routev2","routev3","inputCurrency","currency","outputCurrency","every","equals","numPools","map","reduce","total","cur","poolAddressSet","Set","protocol","add","Pool","getAddress","Pair","size","minimumAmountOut","amountOut","TradeType","EXACT_OUTPUT","slippageAdjustedAmountOut","Fraction","invert","CurrencyAmount","fromRawAmount","maximumAmountIn","amountIn","EXACT_INPUT","slippageAdjustedAmountIn","worstExecutionPrice","Price","fromRoutes","populatedV2Routes","populatedV3Routes","v2Trade","V2TradeSDK","V3TradeSDK","fromRoute","v3Trade","_inputAmount","totalInputFromRoutes","_outputAmount","totalOutputFromRoutes","_executionPrice","_priceImpact","spotOutputAmount","midPrice","quote","priceImpact","subtract","divide","Percent","numerator","denominator","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","encodeV3Swap","singleHop","tokenIn","tokenOut","amountOutMinimum","sqrtPriceLimitX96","amountInMaximum","encodeRouteToPath","encodeSwaps","trades","isSwapAndAdd","swap","v2Andv3Trades","V2Trade","V3Trade","createUncheckedTrade","numberOfTrades","sampleTrade","inputIsNative","isNative","outputIsNative","inputTokenPermit","isToken","SelfPermit","encodePermit","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","encodeRefundETH","calldata","deadlineOrPreviousBlockhash","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","totalAmountSwapped","outputTokenPermit","chainId","zeroForOne","getPositionAmounts","positionAmountIn","positionAmountOut","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","Position","fromAmounts","toString","useFullPrecision","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"8IAgBYA,qqBCdCC,EAAa,6CACbC,EAAe,6CAEfC,EAAOC,EAAKC,OAAO,GACnBC,EAAMF,EAAKC,OAAO,YDmBfE,EAAOC,UACdC,OAAOC,KAAKF,GAASG,MAAK,SAACC,SAAY,cAANA,MAV9BZ,EAAAA,wBAAAA,4DAEVA,iBACAA,qCACAA,qCACAA,yDAQF,IAAsBa,oCAQNC,iBAAP,SAAwBC,UACtBF,EAAeG,UAAUC,mBAAmB,aAAc,CAACF,EAAMG,aAG5DC,yBAAP,SAAgCJ,UAC9BF,EAAeG,UAAUC,mBAAmB,qBAAsB,CAACF,EAAMG,aAGpEE,yBAAP,SAAgCL,UAC9BF,EAAeG,UAAUC,mBAAmB,qBAAsB,CAACF,EAAMG,aAGpEG,iCAAP,SAAwCN,UACtCF,EAAeG,UAAUC,mBAAmB,6BAA8B,CAACF,EAAMG,aAG5EI,0BAAP,SAAiCC,MAC5BA,EAAUC,OAAS,GAA7BC,MAEwB,GAApBF,EAAUC,cACLX,EAAeG,UAAUC,mBAAmB,sBAAuBM,OAEpEG,EAAmBC,6BAA2BX,UAAUC,mBAAmB,YAAa,CAACM,WACxFV,EAAeG,UAAUC,mBAAmB,sBAAuB,CAACS,OAUjEE,mBAAP,SACLC,EACAC,EACAC,EACAC,SAEmDH,EAASI,wBAAwBD,GAArEE,IAATC,QAA8BC,IAATC,eAKvBjC,EAAKkC,SAASR,EAAgBK,QAAQI,SAAUL,KAClDA,EAAaJ,EAAgBK,QAAQI,UAEnCnC,EAAKkC,SAASR,EAAgBO,QAAQE,SAAUH,KAClDA,EAAaN,EAAgBO,QAAQE,UAGnChC,EAAOwB,GACFlB,EAAeG,UAAUC,mBAAmB,OAAQ,CACzD,CACEuB,OAAQX,EAASY,KAAKD,OAAOtB,QAC7BwB,OAAQb,EAASY,KAAKC,OAAOxB,QAC7ByB,IAAKd,EAASY,KAAKE,IACnBC,UAAWf,EAASe,UACpBC,UAAWhB,EAASgB,UACpBX,WAAYY,QAAMZ,GAClBE,WAAYU,QAAMV,GAClBW,UAAWhB,EAAoBgB,aAI5BlC,EAAeG,UAAUC,mBAAmB,oBAAqB,CACtE,CACEuB,OAAQX,EAASY,KAAKD,OAAOtB,QAC7BwB,OAAQb,EAASY,KAAKC,OAAOxB,QAC7BgB,WAAYY,QAAMZ,GAClBE,WAAYU,QAAMV,GAClBY,QAASF,QAAMf,EAAoBiB,eAM7BC,cAAP,SAAqBlC,EAAiBmC,UACnCA,QACDlD,sBAAcmD,WACVtC,EAAeC,iBAAiBC,EAAMqC,cAC1CpD,sBAAcqD,qBACVxC,EAAeM,yBAAyBJ,EAAMqC,cAClDpD,sBAAcsD,qBACVzC,EAAeO,yBAAyBL,EAAMqC,cAClDpD,sBAAcuD,+BACV1C,EAAeQ,iCAAiCN,EAAMqC,sBAEvD,qCA/FEvC,YAAuB,IAAI2C,YAAUC,OEdrD,IAAsBC,oCAQNC,gBAAP,SAAuBpC,EAA8BqC,WAEhC,IAAfA,SACFC,YAAUF,gBAAgBpC,MAI9BuC,MAAMC,QAAQxC,KACjBA,EAAY,CAACA,IAIW,iBAAfqC,GAA2BA,EAAWI,WAAW,MAAO,KAC3DC,EA7BZ,SAAiCC,OAC1BA,EAAQC,MAAM,6BACX,IAAIC,MAASF,mCAGdA,EAAQG,cAwBeC,CAAwBV,UAC3CF,EAAkB1C,UAAUC,mBAAmB,6BAA8B,CAClFgD,EACA1C,QAGIgD,EAAWzB,QAAMc,UAChBF,EAAkB1C,UAAUC,mBAAmB,6BAA8B,CAACsD,EAAUhD,UCtCrG,SAASiD,EAAc7B,UACdG,QAAMH,EAAI8B,SAAS,KAAQlC,UDUpBmB,YAAuB,IAAIF,YAAUC,OCPrD,IAAsBiB,oCAQNC,kBAAP,SAAyBC,EAAqB7B,EAAoB8B,MAE9C,iBAAd9B,SACF+B,WAASH,kBAAkBC,EAAe7B,EAAW8B,MAGxDA,EAAY,KACVE,EAAUP,EAAcK,EAAWlC,KACnCqC,EAAeC,0BAAwBJ,EAAW9B,kBAEjD2B,EAAiB1D,UAAUC,mBAAmB,8CAA+C,CAClG6B,QAAM8B,GACNG,EACAC,WAGKN,EAAiB1D,UAAUC,mBAAmB,uBAAwB,CAAC6B,QAAM8B,QAI1EM,iBAAP,SACLnE,EACA6D,EACA7B,EACA8B,MAGyB,iBAAd9B,SACF+B,WAASI,iBAAiBnE,EAAO6D,EAAe7B,EAAW8B,MAG9DA,EAAY,KACVE,EAAUP,EAAcK,EAAWlC,KACnCqC,EAAeC,0BAAwBJ,EAAW9B,kBAEjD2B,EAAiB1D,UAAUC,mBAAmB,qDAAsD,CACzGF,EAAMG,QACN4B,QAAM8B,GACNG,EACAC,WAGKN,EAAiB1D,UAAUC,mBAAmB,8BAA+B,CAClFF,EAAMG,QACN4B,QAAM8B,QAKEO,WAAP,SAAkBpE,EAAcqE,UAC9BV,EAAiB1D,UAAUC,mBAAmB,OAAQ,CAACF,EAAMG,QAAS4B,QAAMsC,QAGvEC,cAAP,SAAqBD,UACnBV,EAAiB1D,UAAUC,mBAAmB,UAAW,CAAC6B,QAAMsC,4xCA7D3DV,YAAuB,IAAIlB,YAAUC,WCXzC6B,mBCOZ,IAAIC,EAAW,SAAUC,GAGvB,IAAIC,EAAKhF,OAAOiF,UACZC,EAASF,EAAGG,eAEZC,EAA4B,mBAAXC,OAAwBA,OAAS,GAClDC,EAAiBF,EAAQG,UAAY,aACrCC,EAAsBJ,EAAQK,eAAiB,kBAC/CC,EAAoBN,EAAQO,aAAe,gBAE/C,SAASC,EAAOC,EAAKC,EAAKC,GAOxB,OANA/F,OAAOgG,eAAeH,EAAKC,EAAK,CAC9BC,MAAOA,EACPE,YAAY,EACZC,cAAc,EACdC,UAAU,IAELN,EAAIC,GAEb,IAEEF,EAAO,GAAI,IACX,MAAOQ,GACPR,EAAS,SAASC,EAAKC,EAAKC,GAC1B,OAAOF,EAAIC,GAAOC,GAItB,SAASM,EAAKC,EAASC,EAASC,EAAMC,GAEpC,IACIC,EAAY1G,OAAO2G,QADFJ,GAAWA,EAAQtB,qBAAqB2B,EAAYL,EAAUK,GACtC3B,WACzC4B,EAAU,IAAIC,EAAQL,GAAe,IAMzC,OAFAC,EAAUK,QAuMZ,SAA0BT,EAASE,EAAMK,GACvC,IAAIG,EAhLuB,iBAkL3B,OAAO,SAAgBC,EAAQC,GAC7B,GAjLoB,cAiLhBF,EACF,MAAM,IAAIrD,MAAM,gCAGlB,GApLoB,cAoLhBqD,EAA6B,CAC/B,GAAe,UAAXC,EACF,MAAMC,EAKR,MAoQG,CAAEnB,WA1fPoB,EA0fyBC,MAAM,GA9P/B,IAHAP,EAAQI,OAASA,EACjBJ,EAAQK,IAAMA,IAED,CACX,IAAIG,EAAWR,EAAQQ,SACvB,GAAIA,EAAU,CACZ,IAAIC,EAAiBC,EAAoBF,EAAUR,GACnD,GAAIS,EAAgB,CAClB,GAAIA,IAAmBE,EAAkB,SACzC,OAAOF,GAIX,GAAuB,SAAnBT,EAAQI,OAGVJ,EAAQY,KAAOZ,EAAQa,MAAQb,EAAQK,SAElC,GAAuB,UAAnBL,EAAQI,OAAoB,CACrC,GApNqB,mBAoNjBD,EAEF,MADAA,EAlNc,YAmNRH,EAAQK,IAGhBL,EAAQc,kBAAkBd,EAAQK,SAEN,WAAnBL,EAAQI,QACjBJ,EAAQe,OAAO,SAAUf,EAAQK,KAGnCF,EA7NkB,YA+NlB,IAAIa,EAASC,EAASxB,EAASE,EAAMK,GACrC,GAAoB,WAAhBgB,EAAOE,KAAmB,CAO5B,GAJAf,EAAQH,EAAQO,KAlOA,YAFK,iBAwOjBS,EAAOX,MAAQM,EACjB,SAGF,MAAO,CACLzB,MAAO8B,EAAOX,IACdE,KAAMP,EAAQO,MAGS,UAAhBS,EAAOE,OAChBf,EAhPgB,YAmPhBH,EAAQI,OAAS,QACjBJ,EAAQK,IAAMW,EAAOX,OA/QPc,CAAiB1B,EAASE,EAAMK,GAE7CH,EAcT,SAASoB,EAASG,EAAIpC,EAAKqB,GACzB,IACE,MAAO,CAAEa,KAAM,SAAUb,IAAKe,EAAGC,KAAKrC,EAAKqB,IAC3C,MAAOd,GACP,MAAO,CAAE2B,KAAM,QAASb,IAAKd,IAhBjCrB,EAAQsB,KAAOA,EAoBf,IAOImB,EAAmB,GAMvB,SAASZ,KACT,SAASuB,KACT,SAASC,KAIT,IAAIC,EAAoB,GACxBzC,EAAOyC,EAAmB/C,GAAgB,WACxC,OAAOgD,QAGT,IAAIC,EAAWvI,OAAOwI,eAClBC,EAA0BF,GAAYA,EAASA,EAASG,EAAO,MAC/DD,GACAA,IAA4BzD,GAC5BE,EAAOgD,KAAKO,EAAyBnD,KAGvC+C,EAAoBI,GAGtB,IAAIE,EAAKP,EAA2BnD,UAClC2B,EAAU3B,UAAYjF,OAAO2G,OAAO0B,GAYtC,SAASO,EAAsB3D,GAC7B,CAAC,OAAQ,QAAS,UAAU4D,SAAQ,SAAS5B,GAC3CrB,EAAOX,EAAWgC,GAAQ,SAASC,GACjC,OAAOoB,KAAKvB,QAAQE,EAAQC,SAkClC,SAAS4B,EAAcpC,EAAWqC,GAgChC,IAAIC,EAgCJV,KAAKvB,QA9BL,SAAiBE,EAAQC,GACvB,SAAS+B,IACP,OAAO,IAAIF,GAAY,SAASG,EAASC,IAnC7C,SAASC,EAAOnC,EAAQC,EAAKgC,EAASC,GACpC,IAAItB,EAASC,EAASpB,EAAUO,GAASP,EAAWQ,GACpD,GAAoB,UAAhBW,EAAOE,KAEJ,CACL,IAAIsB,EAASxB,EAAOX,IAChBnB,EAAQsD,EAAOtD,MACnB,OAAIA,GACiB,iBAAVA,GACPb,EAAOgD,KAAKnC,EAAO,WACdgD,EAAYG,QAAQnD,EAAMuD,SAASC,MAAK,SAASxD,GACtDqD,EAAO,OAAQrD,EAAOmD,EAASC,MAC9B,SAAS/C,GACVgD,EAAO,QAAShD,EAAK8C,EAASC,MAI3BJ,EAAYG,QAAQnD,GAAOwD,MAAK,SAASC,GAI9CH,EAAOtD,MAAQyD,EACfN,EAAQG,MACP,SAASI,GAGV,OAAOL,EAAO,QAASK,EAAOP,EAASC,MAvBzCA,EAAOtB,EAAOX,KAiCZkC,CAAOnC,EAAQC,EAAKgC,EAASC,MAIjC,OAAOH,EAaLA,EAAkBA,EAAgBO,KAChCN,EAGAA,GACEA,KAkHV,SAAS1B,EAAoBF,EAAUR,GACrC,IAAII,EAASI,EAAS9B,SAASsB,EAAQI,QACvC,QA3TEE,IA2TEF,EAAsB,CAKxB,GAFAJ,EAAQQ,SAAW,KAEI,UAAnBR,EAAQI,OAAoB,CAE9B,GAAII,EAAS9B,SAAiB,SAG5BsB,EAAQI,OAAS,SACjBJ,EAAQK,SAtUZC,EAuUII,EAAoBF,EAAUR,GAEP,UAAnBA,EAAQI,QAGV,OAAOO,EAIXX,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIwC,UAChB,kDAGJ,OAAOlC,EAGT,IAAIK,EAASC,EAASb,EAAQI,EAAS9B,SAAUsB,EAAQK,KAEzD,GAAoB,UAAhBW,EAAOE,KAIT,OAHAlB,EAAQI,OAAS,QACjBJ,EAAQK,IAAMW,EAAOX,IACrBL,EAAQQ,SAAW,KACZG,EAGT,IAAImC,EAAO9B,EAAOX,IAElB,OAAMyC,EAOFA,EAAKvC,MAGPP,EAAQQ,EAASuC,YAAcD,EAAK5D,MAGpCc,EAAQgD,KAAOxC,EAASyC,QAQD,WAAnBjD,EAAQI,SACVJ,EAAQI,OAAS,OACjBJ,EAAQK,SA1XVC,GAoYFN,EAAQQ,SAAW,KACZG,GANEmC,GA3BP9C,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIwC,UAAU,oCAC5B7C,EAAQQ,SAAW,KACZG,GAoDX,SAASuC,EAAaC,GACpB,IAAIC,EAAQ,CAAEC,OAAQF,EAAK,IAEvB,KAAKA,IACPC,EAAME,SAAWH,EAAK,IAGpB,KAAKA,IACPC,EAAMG,WAAaJ,EAAK,GACxBC,EAAMI,SAAWL,EAAK,IAGxB1B,KAAKgC,WAAWC,KAAKN,GAGvB,SAASO,EAAcP,GACrB,IAAIpC,EAASoC,EAAMQ,YAAc,GACjC5C,EAAOE,KAAO,gBACPF,EAAOX,IACd+C,EAAMQ,WAAa5C,EAGrB,SAASf,EAAQL,GAIf6B,KAAKgC,WAAa,CAAC,CAAEJ,OAAQ,SAC7BzD,EAAYoC,QAAQkB,EAAczB,MAClCA,KAAKoC,OAAM,GA8Bb,SAAShC,EAAOiC,GACd,GAAIA,EAAU,CACZ,IAAIC,EAAiBD,EAASrF,GAC9B,GAAIsF,EACF,OAAOA,EAAe1C,KAAKyC,GAG7B,GAA6B,mBAAlBA,EAASd,KAClB,OAAOc,EAGT,IAAKE,MAAMF,EAAS5J,QAAS,CAC3B,IAAI+J,GAAK,EAAGjB,EAAO,SAASA,IAC1B,OAASiB,EAAIH,EAAS5J,QACpB,GAAImE,EAAOgD,KAAKyC,EAAUG,GAGxB,OAFAjB,EAAK9D,MAAQ4E,EAASG,GACtBjB,EAAKzC,MAAO,EACLyC,EAOX,OAHAA,EAAK9D,WA1eToB,EA2eI0C,EAAKzC,MAAO,EAELyC,GAGT,OAAOA,EAAKA,KAAOA,GAKvB,MAAO,CAAEA,KAAMkB,GAIjB,SAASA,IACP,MAAO,CAAEhF,WA1fPoB,EA0fyBC,MAAM,GA+MnC,OA7mBAe,EAAkBlD,UAAYmD,EAC9BxC,EAAO+C,EAAI,cAAeP,GAC1BxC,EAAOwC,EAA4B,cAAeD,GAClDA,EAAkB6C,YAAcpF,EAC9BwC,EACA1C,EACA,qBAaFX,EAAQkG,oBAAsB,SAASC,GACrC,IAAIC,EAAyB,mBAAXD,GAAyBA,EAAOE,YAClD,QAAOD,IACHA,IAAShD,GAG2B,uBAAnCgD,EAAKH,aAAeG,EAAKE,QAIhCtG,EAAQuG,KAAO,SAASJ,GAQtB,OAPIlL,OAAOuL,eACTvL,OAAOuL,eAAeL,EAAQ9C,IAE9B8C,EAAOM,UAAYpD,EACnBxC,EAAOsF,EAAQxF,EAAmB,sBAEpCwF,EAAOjG,UAAYjF,OAAO2G,OAAOgC,GAC1BuC,GAOTnG,EAAQ0G,MAAQ,SAASvE,GACvB,MAAO,CAAEoC,QAASpC,IAsEpB0B,EAAsBE,EAAc7D,WACpCW,EAAOkD,EAAc7D,UAAWO,GAAqB,WACnD,OAAO8C,QAETvD,EAAQ+D,cAAgBA,EAKxB/D,EAAQ2G,MAAQ,SAASpF,EAASC,EAASC,EAAMC,EAAasC,QACxC,IAAhBA,IAAwBA,EAAc4C,SAE1C,IAAIC,EAAO,IAAI9C,EACbzC,EAAKC,EAASC,EAASC,EAAMC,GAC7BsC,GAGF,OAAOhE,EAAQkG,oBAAoB1E,GAC/BqF,EACAA,EAAK/B,OAAON,MAAK,SAASF,GACxB,OAAOA,EAAOjC,KAAOiC,EAAOtD,MAAQ6F,EAAK/B,WAuKjDjB,EAAsBD,GAEtB/C,EAAO+C,EAAIjD,EAAmB,aAO9BE,EAAO+C,EAAIrD,GAAgB,WACzB,OAAOgD,QAGT1C,EAAO+C,EAAI,YAAY,WACrB,MAAO,wBAkCT5D,EAAQ9E,KAAO,SAAS4L,GACtB,IAAI5L,EAAO,GACX,IAAK,IAAI6F,KAAO+F,EACd5L,EAAKsK,KAAKzE,GAMZ,OAJA7F,EAAK6L,UAIE,SAASjC,IACd,KAAO5J,EAAKc,QAAQ,CAClB,IAAI+E,EAAM7F,EAAK8L,MACf,GAAIjG,KAAO+F,EAGT,OAFAhC,EAAK9D,MAAQD,EACb+D,EAAKzC,MAAO,EACLyC,EAQX,OADAA,EAAKzC,MAAO,EACLyC,IAsCX9E,EAAQ2D,OAASA,EAMjB5B,EAAQ7B,UAAY,CAClBmG,YAAatE,EAEb4D,MAAO,SAASsB,GAcd,GAbA1D,KAAK2D,KAAO,EACZ3D,KAAKuB,KAAO,EAGZvB,KAAKb,KAAOa,KAAKZ,WArgBjBP,EAsgBAmB,KAAKlB,MAAO,EACZkB,KAAKjB,SAAW,KAEhBiB,KAAKrB,OAAS,OACdqB,KAAKpB,SA1gBLC,EA4gBAmB,KAAKgC,WAAWzB,QAAQ2B,IAEnBwB,EACH,IAAK,IAAIX,KAAQ/C,KAEQ,MAAnB+C,EAAKa,OAAO,IACZhH,EAAOgD,KAAKI,KAAM+C,KACjBR,OAAOQ,EAAKc,MAAM,MACrB7D,KAAK+C,QAphBXlE,IA0hBFiF,KAAM,WACJ9D,KAAKlB,MAAO,EAEZ,IACIiF,EADY/D,KAAKgC,WAAW,GACLG,WAC3B,GAAwB,UAApB4B,EAAWtE,KACb,MAAMsE,EAAWnF,IAGnB,OAAOoB,KAAKgE,MAGd3E,kBAAmB,SAAS4E,GAC1B,GAAIjE,KAAKlB,KACP,MAAMmF,EAGR,IAAI1F,EAAUyB,KACd,SAASkE,EAAOC,EAAKC,GAYnB,OAXA7E,EAAOE,KAAO,QACdF,EAAOX,IAAMqF,EACb1F,EAAQgD,KAAO4C,EAEXC,IAGF7F,EAAQI,OAAS,OACjBJ,EAAQK,SArjBZC,KAwjBYuF,EAGZ,IAAK,IAAI5B,EAAIxC,KAAKgC,WAAWvJ,OAAS,EAAG+J,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQ3B,KAAKgC,WAAWQ,GACxBjD,EAASoC,EAAMQ,WAEnB,GAAqB,SAAjBR,EAAMC,OAIR,OAAOsC,EAAO,OAGhB,GAAIvC,EAAMC,QAAU5B,KAAK2D,KAAM,CAC7B,IAAIU,EAAWzH,EAAOgD,KAAK+B,EAAO,YAC9B2C,EAAa1H,EAAOgD,KAAK+B,EAAO,cAEpC,GAAI0C,GAAYC,EAAY,CAC1B,GAAItE,KAAK2D,KAAOhC,EAAME,SACpB,OAAOqC,EAAOvC,EAAME,UAAU,GACzB,GAAI7B,KAAK2D,KAAOhC,EAAMG,WAC3B,OAAOoC,EAAOvC,EAAMG,iBAGjB,GAAIuC,GACT,GAAIrE,KAAK2D,KAAOhC,EAAME,SACpB,OAAOqC,EAAOvC,EAAME,UAAU,OAG3B,CAAA,IAAIyC,EAMT,MAAM,IAAIjJ,MAAM,0CALhB,GAAI2E,KAAK2D,KAAOhC,EAAMG,WACpB,OAAOoC,EAAOvC,EAAMG,gBAU9BxC,OAAQ,SAASG,EAAMb,GACrB,IAAK,IAAI4D,EAAIxC,KAAKgC,WAAWvJ,OAAS,EAAG+J,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQ3B,KAAKgC,WAAWQ,GAC5B,GAAIb,EAAMC,QAAU5B,KAAK2D,MACrB/G,EAAOgD,KAAK+B,EAAO,eACnB3B,KAAK2D,KAAOhC,EAAMG,WAAY,CAChC,IAAIyC,EAAe5C,EACnB,OAIA4C,IACU,UAAT9E,GACS,aAATA,IACD8E,EAAa3C,QAAUhD,GACvBA,GAAO2F,EAAazC,aAGtByC,EAAe,MAGjB,IAAIhF,EAASgF,EAAeA,EAAapC,WAAa,GAItD,OAHA5C,EAAOE,KAAOA,EACdF,EAAOX,IAAMA,EAET2F,GACFvE,KAAKrB,OAAS,OACdqB,KAAKuB,KAAOgD,EAAazC,WAClB5C,GAGFc,KAAKwE,SAASjF,IAGvBiF,SAAU,SAASjF,EAAQwC,GACzB,GAAoB,UAAhBxC,EAAOE,KACT,MAAMF,EAAOX,IAcf,MAXoB,UAAhBW,EAAOE,MACS,aAAhBF,EAAOE,KACTO,KAAKuB,KAAOhC,EAAOX,IACM,WAAhBW,EAAOE,MAChBO,KAAKgE,KAAOhE,KAAKpB,IAAMW,EAAOX,IAC9BoB,KAAKrB,OAAS,SACdqB,KAAKuB,KAAO,OACa,WAAhBhC,EAAOE,MAAqBsC,IACrC/B,KAAKuB,KAAOQ,GAGP7C,GAGTuF,OAAQ,SAAS3C,GACf,IAAK,IAAIU,EAAIxC,KAAKgC,WAAWvJ,OAAS,EAAG+J,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQ3B,KAAKgC,WAAWQ,GAC5B,GAAIb,EAAMG,aAAeA,EAGvB,OAFA9B,KAAKwE,SAAS7C,EAAMQ,WAAYR,EAAMI,UACtCG,EAAcP,GACPzC,IAKbwF,MAAS,SAAS9C,GAChB,IAAK,IAAIY,EAAIxC,KAAKgC,WAAWvJ,OAAS,EAAG+J,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQ3B,KAAKgC,WAAWQ,GAC5B,GAAIb,EAAMC,SAAWA,EAAQ,CAC3B,IAAIrC,EAASoC,EAAMQ,WACnB,GAAoB,UAAhB5C,EAAOE,KAAkB,CAC3B,IAAIkF,EAASpF,EAAOX,IACpBsD,EAAcP,GAEhB,OAAOgD,GAMX,MAAM,IAAItJ,MAAM,0BAGlBuJ,cAAe,SAASvC,EAAUf,EAAYE,GAa5C,OAZAxB,KAAKjB,SAAW,CACd9B,SAAUmD,EAAOiC,GACjBf,WAAYA,EACZE,QAASA,GAGS,SAAhBxB,KAAKrB,SAGPqB,KAAKpB,SA9rBPC,GAisBOK,IAQJzC,GAOsBoI,EAAOpI,SAGtC,IACEqI,mBAAqBtI,EACrB,MAAOuI,GAWmB,iBAAfC,WACTA,WAAWF,mBAAqBtI,EAEhCyI,SAAS,IAAK,yBAAdA,CAAwCzI,iCD/uBhCD,EAAAA,mBAAAA,8BAEVA,cEcW2I,yBAOCC,8BACJA,EAAQC,MAAOD,EAAQE,MAAOF,EAAQG,wBAJT/I,iBAASgJ,KAKvCC,MAAQC,EAAKL,yBARZM,SAaGC,yBAOCC,8BACJA,EAAQJ,MAAOI,EAAQP,MAAOO,EAAQN,wBAJT/I,iBAASsJ,KAKvCC,KAAOF,EAAQG,6BARdC,SCvBGC,+BAkBTC,IAAAA,SACAC,IAAAA,SACAC,IAAAA,eAcKC,MAAQ,QACRC,OAAS,iBAEuCJ,kBAAU,eAAzCK,IAAAA,YAAaC,IAAAA,aAC3BC,EAAQ,IAAIvB,IADPwB,cAENJ,OAAOrE,KAAKwE,QACZJ,MAAMpE,KAAK,CACdwE,MAAAA,EACAF,YAAAA,EACAC,aAAAA,kBAIiDL,kBAAU,eAAzCI,IAAAA,YAAaC,IAAAA,aAC3BC,EAAQ,IAAId,IADPgB,cAENL,OAAOrE,KAAKwE,QACZJ,MAAMpE,KAAK,CACdwE,MAAAA,EACAF,YAAAA,EACAC,aAAAA,SAGCJ,UAAYA,MAGXQ,EAAgB5G,KAAKqG,MAAM,GAAGE,YAAYM,SAC1CC,EAAiB9G,KAAKqG,MAAM,GAAGG,aAAaK,SAEhD7G,KAAKqG,MAAMU,OAAM,mBAAeH,EAAcvM,QAAQ2M,SAAlCP,MAA+CpB,MAAMhL,aAD3E3B,MAKEsH,KAAKqG,MAAMU,OAAM,mBAAeD,EAAezM,QAAQ2M,SAAnCP,MAAgDnB,OAAOjL,aAD7E3B,gBAMMuO,EAAWjH,KAAKqG,MAAMa,KAAI,qBAAGT,MAAkBjB,MAAM/M,UAAQ0O,QAAO,SAACC,EAAOC,UAAQD,EAAQC,IAAK,GACjGC,EAAiB,IAAIC,QACHvH,KAAKqG,gCAAhBI,UAAAA,UACQA,EAAMjB,sBAAO,KAArB9L,UACL+M,EAAMe,UAAYjL,iBAASsJ,GAC7ByB,EAAeG,IAAIC,OAAKC,WAAWjO,EAAKD,OAAQC,EAAKC,OAASD,EAAcE,MAG5E0N,EAAeG,IAAIG,OAAKD,WADXjO,EAC2BD,OAD3BC,EACwCC,SAIjDsN,GAAYK,EAAeO,MAArCnP,mCA8EKoP,iBAAA,SAAiB7O,EAA4B8O,eAAAA,IAAAA,EAAY/H,KAAKwG,cACxDvN,EAAkBM,SAASnC,IAAtCsB,MACIsH,KAAKoG,YAAc4B,YAAUC,oBACxBF,MAEDG,EAA4B,IAAIC,WAAS5Q,GAC5CkQ,IAAIxO,GACJmP,SACA1M,SAASqM,EAAUvO,UAAUA,gBACzB6O,iBAAeC,cAAcP,EAAUlB,SAAUqB,MASrDK,gBAAA,SAAgBtP,EAA4BuP,eAAAA,IAAAA,EAAWxI,KAAKuG,aACtDtN,EAAkBM,SAASnC,IAAtCsB,MACIsH,KAAKoG,YAAc4B,YAAUS,mBACxBD,MAEDE,EAA2B,IAAIP,WAAS5Q,GAAKkQ,IAAIxO,GAAmByC,SAAS8M,EAAShP,UAAUA,gBAC/F6O,iBAAeC,cAAcE,EAAS3B,SAAU6B,MASpDC,oBAAA,SAAoB1P,UAClB,IAAI2P,QACT5I,KAAKuG,YAAYM,SACjB7G,KAAKwG,aAAaK,SAClB7G,KAAKuI,gBAAgBtP,GAAmBO,SACxCwG,KAAK8H,iBAAiB7O,GAAmBO,aAIzBqP,sCAAb,WACL3C,EAIAC,EAIAC,oGAEM0C,EAIA,GAEAC,EAIA,OAE4B7C,kBAC1B8C,EAAU,IAAIC,QADTvC,cAAAA,UAASrK,OAC4B+J,GAGhD0C,EAAkB7G,KAAK,CACrByE,QAAAA,EACAH,YAJoCyC,EAA9BzC,YAKNC,aALoCwC,EAAjBxC,mBASWL,kDAArBQ,cAAAA,QAAStK,IAAAA,gBACE6M,QAAWC,UAAUxC,EAAStK,EAAQ+J,UAG5D2C,EAAkB9G,KAAK,CACrB0E,QAAAA,EACAJ,aALI6C,UACE7C,YAKNC,aALoC4C,EAAjB5C,uEAShB,IAAIP,EAAM,CACfC,SAAU4C,EACV3C,SAAU4C,EACV3C,UAAAA,6GAIgB+C,qCAAb,WACL1C,EACApK,EACA+J,mFAcIK,aAAiBf,yBACbsD,EAAU,IAAIC,QAAWxC,EAAOpK,EAAQ+J,GAE9CF,EAAW,CAAC,CAAEQ,QAASD,EAAOF,YADQyC,EAA9BzC,YACmCC,aADLwC,EAAjBxC,eAErBL,EAAW,0CAEW+C,QAAWC,UAAU1C,EAAOpK,EAAQ+J,UAE1DD,EAAW,CAAC,CAAEQ,QAASF,EAAOF,aAFxB6C,UACE7C,YACmCC,aADL4C,EAAjB5C,eAErBN,EAAW,oCAEN,IAAID,EAAM,CACfC,SAAAA,EACAC,SAAAA,EACAC,UAAAA,sIAxMJ,cACMpG,KAAKqJ,oBACArJ,KAAKqJ,iBAGRzC,EAAgB5G,KAAKqG,MAAM,GAAGE,YAAYM,SAC1CyC,EAAuBtJ,KAAKqG,MAC/Ba,KAAI,qBAAGX,eACPY,QAAO,SAACC,EAAOC,UAAQD,EAAMK,IAAIJ,KAAMgB,iBAAeC,cAAc1B,EAAe,gBAEjFyC,aAAeC,EACbtJ,KAAKqJ,uCAGd,cACMrJ,KAAKuJ,qBACAvJ,KAAKuJ,kBAGRzC,EAAiB9G,KAAKqG,MAAM,GAAGG,aAAaK,SAC5C2C,EAAwBxJ,KAAKqG,MAChCa,KAAI,qBAAGV,gBACPW,QAAO,SAACC,EAAOC,UAAQD,EAAMK,IAAIJ,KAAMgB,iBAAeC,cAAcxB,EAAgB,gBAElFyC,cAAgBC,EACdxJ,KAAKuJ,0CAQd,iCAEIvJ,KAAKyJ,mBACJzJ,KAAKyJ,gBAAkB,IAAIb,QAC1B5I,KAAKuG,YAAYM,SACjB7G,KAAKwG,aAAaK,SAClB7G,KAAKuG,YAAY/M,SACjBwG,KAAKwG,aAAahN,mCAaxB,cACMwG,KAAK0J,oBACA1J,KAAK0J,uBAGVC,EAAmBtB,iBAAeC,cAActI,KAAKwG,aAAaK,SAAU,OAC3C7G,KAAKqG,sBAAO,eAE/CsD,EAAmBA,EAAiBlC,MAFzBhB,MACYmD,SAC0BC,QAF/BtD,kBAKduD,EAAcH,EAAiBI,SAAS/J,KAAKwG,cAAcwD,OAAOL,eACnED,aAAe,IAAIO,UAAQH,EAAYI,UAAWJ,EAAYK,aAE5DnK,KAAK0J,2MCxIVtS,EAAOC,EAAKC,OAAO,GA0CH8S,oCAQLC,aAAP,SACNC,EACA7S,EACA8S,EACAC,OAEMhC,EAAmBzO,QAAMuQ,EAAM/B,gBAAgB9Q,EAAQwB,mBAAmBO,UAC1EuO,EAAoBhO,QAAMuQ,EAAMxC,iBAAiBrQ,EAAQwB,mBAAmBO,UAE5EsM,EAAOwE,EAAM7D,MAAMX,KAAKoB,KAAI,SAAClP,UAAUA,EAAMG,WAC7C6B,EAAYuQ,EACdpT,OAC6B,IAAtBM,EAAQuC,UACf9C,EACAgF,0BAAwBzE,EAAQuC,kBAEhCsQ,EAAMlE,YAAc4B,YAAUS,YAGzB2B,EAAWnS,UAAUC,mBAAmB,2BAFtB,CAACsQ,EAAUgC,EAAiC,EAAIzC,EAAWjC,EAAM9L,IAMnFoQ,EAAWnS,UAAUC,mBAAmB,2BAFrB,CAAC6P,EAAWS,EAAU1C,EAAM9L,OAM3CyQ,aAAP,SACNH,EACA7S,EACA8S,EACAC,aAEMhS,EAAsB,OAEuB8R,EAAMjE,sBAAO,eAAnDI,IAAAA,MAAoBD,IAAAA,aACzBgC,EAAmBzO,QAAMuQ,EAAM/B,gBAAgB9Q,EAAQwB,oBAD3CsN,aAC2E/M,UACvFuO,EAAoBhO,QAAMuQ,EAAMxC,iBAAiBrQ,EAAQwB,kBAAmBuN,GAAchN,UAG1FkR,EAAmC,IAAvBjE,EAAMjB,MAAM/M,OAExBuB,EAAYuQ,EACdpT,OAC6B,IAAtBM,EAAQuC,UACf9C,EACAgF,0BAAwBzE,EAAQuC,cAEhC0Q,EAYAlS,EAAUyJ,KAXRqI,EAAMlE,YAAc4B,YAAUS,YAWjB2B,EAAWnS,UAAUC,mBAAmB,mBAAoB,CAV5C,CAC7ByS,QAASlE,EAAMV,UAAU,GAAG5N,QAC5ByS,SAAUnE,EAAMV,UAAU,GAAG5N,QAC7ByB,IAAK6M,EAAMjB,MAAM,GAAG5L,IACpBI,UAAAA,EACAwO,SAAAA,EACAqC,iBAAkBL,EAAiC,EAAIzC,EACvD+C,kBAAmB,KAeNV,EAAWnS,UAAUC,mBAAmB,oBAAqB,CAV5C,CAC9ByS,QAASlE,EAAMV,UAAU,GAAG5N,QAC5ByS,SAAUnE,EAAMV,UAAU,GAAG5N,QAC7ByB,IAAK6M,EAAMjB,MAAM,GAAG5L,IACpBI,UAAAA,EACA+N,UAAAA,EACAgD,gBAAiBvC,EACjBsC,kBAAmB,UAKlB,KACChF,EAAekF,oBAAkBvE,EAAO6D,EAAMlE,YAAc4B,YAAUC,cAU1EzP,EAAUyJ,KARRqI,EAAMlE,YAAc4B,YAAUS,YAQjB2B,EAAWnS,UAAUC,mBAAmB,aAAc,CAP5C,CACvB4N,KAAAA,EACA9L,UAAAA,EACAwO,SAAAA,EACAqC,iBAAkBL,EAAiC,EAAIzC,KAY1CqC,EAAWnS,UAAUC,mBAAmB,cAAe,CAP5C,CACxB4N,KAAAA,EACA9L,UAAAA,EACA+N,UAAAA,EACAgD,gBAAiBvC,cAQlBhQ,KAGMyS,YAAP,SACNC,EAKAzT,EACA0T,MAYID,aAAkBjF,EAAO,CAEzBiF,EAAO7E,MAAMU,OAAM,SAACqE,UAASA,EAAK3E,MAAMe,UAAYjL,iBAASsJ,IAAMuF,EAAK3E,MAAMe,UAAYjL,iBAASgJ,OADrG7M,gBAKI2S,EAAqG,OAEtDH,EAAO7E,sBAAO,eAApDI,IAAAA,MAAOF,IAAAA,YAAaC,IAAAA,aAC3BC,EAAMe,UAAYjL,iBAASgJ,GAC7B8F,EAAcpJ,KACZ,IAAIqJ,QACF7E,EACAyE,EAAO9E,WAAa4B,YAAUS,YAAclC,EAAcC,EAC1D0E,EAAO9E,YAGFK,EAAMe,UAAYjL,iBAASsJ,IACpCwF,EAAcpJ,KACZsJ,QAAQC,qBAAqB,CAC3B/E,MAAOA,EACPF,YAAAA,EACAC,aAAAA,EACAJ,UAAW8E,EAAO9E,aAK1B8E,EAASG,EAGNtQ,MAAMC,QAAQkQ,KACjBA,EAAS,CAACA,QAGNO,EAAiBP,EAAO/D,QAC5B,SAACsE,EAAgBnB,UAAUmB,GAAkBnB,aAAiBiB,QAAUjB,EAAMjE,MAAM5N,OAAS,KAC7F,GAGIiT,EAAcR,EAAO,GAIzBA,EAAOnE,OAAM,SAACuD,UAAUA,EAAM/D,YAAYM,SAASG,OAAO0E,EAAYnF,YAAYM,cADpFnO,MAKEwS,EAAOnE,OAAM,SAACuD,UAAUA,EAAM9D,aAAaK,SAASG,OAAO0E,EAAYlF,aAAaK,cADtFnO,MAKEwS,EAAOnE,OAAM,SAACuD,UAAUA,EAAMlE,YAAcsF,EAAYtF,cAD1D1N,UAKMF,EAAsB,GAEtBmT,EAAgBD,EAAYnF,YAAYM,SAAS+E,SACjDC,EAAiBH,EAAYlF,aAAaK,SAAS+E,SAMnDpB,EAAiCkB,EAAYtF,YAAc4B,YAAUS,aAAegD,EAAiB,EAMrGlB,EAAoBsB,KAAoBpU,EAAQmC,OAASuR,GAAgBX,EAG3E/S,EAAQqU,mBACAJ,EAAYnF,YAAYM,SAASkF,SAA3CrT,MACAF,EAAUyJ,KAAK+J,aAAWC,aAAaP,EAAYnF,YAAYM,SAAUpP,EAAQqU,kCAG/DZ,kBAAQ,KAAjBZ,aACLA,aAAiBgB,QACnB9S,EAAUyJ,KAAKmI,EAAWC,aAAaC,EAAO7S,EAAS8S,EAAmBC,uBAEnDJ,EAAWK,aAChCH,EACA7S,EACA8S,EACAC,mBAEAhS,EAAUyJ,kBAKViK,EAAoC7D,iBAAeC,cAAcoD,EAAYnF,YAAYM,SAAU,GACnGsF,EAAqC9D,iBAAeC,cAAcoD,EAAYlF,aAAaK,SAAU,GAErGiB,EAA6CoD,EAAO/D,QACxD,SAACiF,EAAK9B,UAAU8B,EAAI3E,IAAI6C,EAAMxC,iBAAiBrQ,EAAQwB,sBACvDkT,GAGIE,EAA2CnB,EAAO/D,QACtD,SAACiF,EAAK9B,UAAU8B,EAAI3E,IAAI6C,EAAM9D,gBAC9B2F,GAGIG,EAA0CpB,EAAO/D,QACrD,SAACiF,EAAK9B,UAAU8B,EAAI3E,IAAI6C,EAAM/B,gBAAgB9Q,EAAQwB,sBACtDiT,SAGK,CACL1T,UAAAA,EACAkT,YAAAA,EACAnB,kBAAAA,EACAoB,cAAAA,EACAE,eAAAA,EACAS,cAAAA,EACAxE,iBAAAA,EACAuE,eAAAA,MASUE,mBAAP,SACLrB,EAKAzT,SAUI2S,EAAWa,YAAYC,EAAQzT,GAPjCe,IAAAA,UACAkT,IAAAA,YAEAC,IAAAA,cAEAW,IAAAA,cACAxE,IAAAA,0BAJAyC,mBAUE/R,EAAUyJ,OARZ4J,eAQiBlQ,EAAiBC,kBAAkBkM,EAAiBtO,SAAU/B,EAAQuC,UAAWvC,EAAQmC,KAGtG+B,EAAiBQ,iBACfuP,EAAYlF,aAAaK,SAASxM,QAClCyN,EAAiBtO,SACjB/B,EAAQuC,UACRvC,EAAQmC,MAOZ+R,GAAiBD,EAAYtF,YAAc4B,YAAUC,cACvDzP,EAAUyJ,KAAKlG,WAASyQ,mBAGnB,CACLC,SAAU9R,EAAkBC,gBAAgBpC,EAAWf,EAAQiV,6BAC/DjP,MAAO1D,QAAM4R,EAAgBW,EAAc9S,SAAWpC,OAS5CuV,yBAAP,SACLzB,EAKAzT,EACAqB,EACAE,EACA4T,EACAC,SAUIzC,EAAWa,YAAYC,EAAQzT,GAAS,GAP1Ce,IAAAA,UACAmT,IAAAA,cACAE,IAAAA,eACAH,IAAAA,YACeoB,IAAfR,cACAD,IAAAA,eACAvE,IAAAA,iBAIErQ,EAAQsV,oBACAV,EAAexF,SAASkF,SAAlCrT,MACAF,EAAUyJ,KAAK+J,aAAWC,aAAaI,EAAexF,SAAUpP,EAAQsV,yBAGpEC,EAAUtB,EAAYjF,MAAMuG,QAC5BC,EAAanU,EAASY,KAAKD,OAAOY,QAAQlC,UAAY2U,EAAmBjG,SAASxM,QAAQlC,UAChDiS,EAAW8C,mBAAmBpU,EAAUmU,GAAhFE,IAAAA,iBAAkBC,IAAAA,kBAGpBzC,EAAUgB,EAAgB0B,QAAML,GAAWG,EAAiBtG,SAASxM,QACrEuQ,EAAWiB,EAAiBwB,QAAML,GAAWI,EAAkBvG,SAASxM,QAGxEiT,EAAqBF,EAAkBrD,SAASsC,EAAehS,SACjEiT,EAAmBC,YAAYlF,iBAAeC,cAAc8E,EAAkBvG,SAAU,KAItFrO,EAAUyJ,KADd4J,EACmBlQ,EAAiBW,cAAcgR,EAAmB9T,UAClDmC,EAAiBS,WAAWwO,EAAU0C,EAAmB9T,WAK1EhB,EAAUyJ,KADd0J,EACmBhQ,EAAiBW,cAAc6Q,EAAiB3T,UAChDmC,EAAiBS,WAAWuO,EAASwC,EAAiB3T,WAGrEoT,IAAwB3V,sBAAcuW,cACxChV,EAAUyJ,KAAKnK,EAAeoC,cAAcyQ,EAASiC,IACnDC,IAAyB5V,sBAAcuW,cACzChV,EAAUyJ,KAAKnK,EAAeoC,cAAc0Q,EAAUiC,QA0BpDpP,EAtBE1E,EAAkB0U,WAASC,YAAY,CAC3ChU,KAAMZ,EAASY,KACfG,UAAWf,EAASe,UACpBC,UAAWhB,EAASgB,UACpBV,QAAS6T,EAAanU,EAASM,QAAQI,SAASmU,WAAa7F,EAAiBtO,SAASmU,WACvFrU,QAAS2T,EAAanF,EAAiBtO,SAASmU,WAAa7U,EAASQ,QAAQE,SAASmU,WACvFC,kBAAkB,WAIpBpV,EAAUyJ,KACRnK,EAAee,mBAAmBC,EAAUC,EAAiBC,EAAqBvB,EAAQwB,oBAKxFT,EAAUyJ,KADd0J,EACmBhQ,EAAiBC,kBAAkBxE,GACnCuE,EAAiBQ,iBAAiBwO,EAASvT,IAE1DoB,EAAUyJ,KADd4J,EACmBlQ,EAAiBC,kBAAkBxE,GACnCuE,EAAiBQ,iBAAiByO,EAAUxT,IAI7DqG,EADEkO,EACMmB,EAAmBzS,QAAQoN,IAAI0F,EAAiB9S,SAASb,SACxDqS,EACDyB,EAAmB9T,SAEnBpC,EAGH,CACLqV,SAAU9R,EAAkBC,gBAAgBpC,EAAWf,EAAQiV,6BAC/DjP,MAAOA,EAAMkQ,eAIFT,mBAAP,SACNpU,EACAmU,SAE6BnU,EAAS+U,YAArBvU,IAAAA,QACXwU,EAAkBzF,iBAAeC,cAAcxP,EAASY,KAAKD,SAD3DL,SAEF2U,EAAkB1F,iBAAeC,cAAcxP,EAASY,KAAKC,OAAQL,KAE7B2T,EAC1C,CAACa,EAAiBC,GAClB,CAACA,EAAiBD,SACf,CAAEX,sBAAkBC,8BA9ZfhD,YAAuB,IAAI3P,YAAUC"}